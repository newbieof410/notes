# Docker 简介
> 源文档链接: [Docker overview](https://docs.docker.com/engine/docker-overview/)

`Docker` 是开发, 迁移和运行应用程序的开放平台. Docker 使你可以将应用程序和基础设施分隔开来, 因而能更快地交付软件. 有了 Docker, 你可以像管理应用程序一样管理基础设施. 使用 Docker 可以显著地缩短编写代码和在生产环境中运行之间的过程.

## Docker 平台
Docker 将应用程序打包, 并运行在一个称为容器的宽松隔离环境中. 隔离性和安全性使得多个容器可以同时运行在一个宿主机上. 说容器轻量是因为不需要额外的虚拟机管理器, 而是直接运行在宿主机的内核中. 这就意味着, 在同样配置的物理设备上, 相比虚拟机能运行更多数量的容器. 甚至在虚拟机中也能运行 Docker!

Docker 提供了管理容器生命周期的工具和平台:
- 使用容器开发你的应用和它的支撑组件.
- 容器成为分发和测试应用程序的一部分.
- 当你准备就绪, 以容器或编排服务的形式将应用部署到生产环境. 不论你的生产环境是一个本地数据中心, 是一个云平台, 或是前两者的混合环境都是一样的.

## Docker 引擎
Docker 引擎是一个客户端-服务器应用, 有下面的主要组件:
- 服务器, 作为守护进程持续运行 (`dockerd` 命令);
- `REST API`, 应用程序与 Docker 守护进程沟通的接口;
- 命令行接口 (`CLI`) 客户端 (`docker` 命令).

<div align="center">
  <img src="https://docs.docker.com/engine/images/engine-components-flow.png" alt="Docker Engine Components Flow">
</div>

CLI 使用 Docker REST API 进行控制, 也可以通过脚本或者直接使用 CLI 命令与 Docker 守护进程交互.

守护进程创建管理 Docker 对象, 例如镜像, 容器, 网络和存储卷.

## Docker 能用来做什么?
**快速, 一致地交付软件**

Docker 使开发者能够使用本地容器 (它提供了你的应用和服务) 在标准化的环境中开发, 从而精简了开发工作的生命周期. 容器非常适合持续集成和持续交付 (CI/CD) 工作流程.

比如在下面的几个场景中:
- 开发人员在本地编写代码, 再使用 Docker 容器与同事分享工作成果.
- 使用 Docker 把应用程序推送到测试环境中, 执行自动和手动测试.
- 当开发人员找到了 bug, 他们可以在开发环境中修改好, 再重新部署到测试环境中去测试和验证.
- 当测试完成之后, 把修正版本提交给客户就如把更新后的镜像推送到生产环境中一样容易.

**敏捷地部署和扩容**

Docker 提供的基于容器的平台可支持高度可移植的工作负载. Docker 容器可以运行在开发者的本地笔记本中, 运行在数据中心的物理或虚拟机上, 运行在云平台上, 又或者在混合环境中.

Docker 的可移植和轻量的特性, 同样使得动态管理工作负载变得容易, 接近实时地根据业务需求扩容或拆除应用程序和服务.

**在同样的硬件配置上运行更多的工作负载**

Docker 轻且快. 它是基于虚拟机管理器的虚拟机的一种可行, 高效的替代品. 因此可以更好地利用硬件资源实现业务目标. Docker 很适合应用于高密度环境中, 对中小型部署环境来说也能使你用较少的资源做的更多.

## Docker 架构
Docker 使用客户端--服务器架构. Docker 客户端与守护进程交互, 由守护进程完成构建, 运行和分发 Docker 容器的工作. Docker 客户端和守护进程可以运行在同一个系统中, 或者也可以通过 Docker 客户端连接到远程的 Docker 守护进程. Docker 客户端和守护进程在 `UNIX sockets` 或网络接口之上, 通过 REST API 进行交互.

<div align="center">
  <img src="https://docs.docker.com/engine/images/architecture.svg" alt="Docker Architecture Diagram">
</div>

### Docker 守护进程
Docker 守护进程 (`dockerd`) 监听 Docker API 的请求, 并且管理 Docker 对象, 例如, 镜像, 容器, 网络和存储卷. 一个守护进程也能与其他守护进程沟通, 以管理 Docker 服务.

### Docker 客户端
Docker 客户端 (`docker`) 是用户与 Docker 交互的主要方法. 当输入命令如 `docker run` 时, 客户端会将命令发送到 `dockerd`, 再由它来执行. `docker` 命令使用 Docker API. Docker 客户端可以与多个守护进程交互.

### Docker 仓库
Docker 仓库用来存储 Docker 镜像. Docker Hub 和 Docker Cloud 是任何人都可以使用的公共仓库, 默认配置 Docker 从 Docker Hub 上查找镜像. 如果你使用 Docker 数据中心 (DDC), 其中会包含 Docker 认可的仓库 (DTR).

当你使用 `docker pull` 或 `docker run` 命令, 会从配置的仓库中拉取需要的镜像. 当你使用 `docker push` 命令, 你的镜像也会推送到配置的仓库中.

你可以在 [Docker 商店](http://store.docker.com/) 里购买, 出售或者免费提供 Docker 镜像.

### Docker 对象
在使用 Docker 时, 你会创建和使用镜像, 容器, 网络, 卷, 插件和其他对象. 这一部分会对其中的一些对象做简要介绍.

#### 镜像
镜像是一个只读的模板, 包含创建 Docker 容器的指令. 通常, 一个镜像会构建在另一个镜像之上, 再加上一些自己的修改. 例如, 你可以在 `ubuntu` 镜像之上, 构建一个自己的镜像, 但是你在上面安装了 Apache web 服务器和自己的应用程序, 还有相应的配置.

你可以自己构建镜像或者只是去使用别人创建的, 发布在仓库中的镜像. 构建镜像需要用到 `Dockerfile` 文件, 它使用一些简单的语法来定义构建和运行镜像的步骤. Dockerfile 中的每一条指令都会在镜像中创建一层. 当你修改了 Dockerfile 重新构建镜像, 只有那些修改的镜像层会被重建. 这也是相比于虚拟化技术, 镜像更轻, 小, 快的部分原因.

#### 容器
容器是镜像的可运行实例. 你可以使用 Docker API 或 CLI 创建, 开启, 停止, 移动或是删除容器. 你可以给容器连接一个或多个网络, 附加存储, 或者在容器的当前状态上创建新的镜像.

在默认状态下, 容器相对地隔离于其他容器和主机. 你可以控制容器的网络, 存储或其他底层子系统如何与别的容器和宿主机隔离开.

容器由镜像, 以及你在创建或启动时使用的配置选项定义. 当一个容器被删除, 之前做的任何没有保存在持久存储中的修改都会丢失.

##### `docker run` 命令示例
下面的命令会运行一个 `ubuntu` 容器, 交互地附加在本地命令行会话中, 并运行 `/bin/bash`.
```
$ docker run -i -t ubuntu /bin/bash
```
当你运行这条命令, Docker 在背后执行了下面这些操作 (假设你使用的是默认的仓库配置):
1. 如果本地没有 `ubuntu` 镜像, Docker 会从你配置的仓库中拉取, 效果等同于手动执行 `docker pull ubuntu` 命令.
1. Docker 创建新的容器, 如同手动执行 `docker container create`.
1. 给容器分配一个读写文件系统, 作为最顶层. 这使得运行中的容器可以在其文件系统中创建或修改文件和目录.
1. 创建网络接口, 将容器连接到默认的网络, 因为在上面这条命令中没有明确指定网络选项. 这一步包括给容器分配 IP 地址. 容器默认能使用主机网络连接接入外部网络.
1. 启动容器, 执行 `/bin/bash`. 因为容器以交互方式运行, 并且附加到了你的终端上 (因为使用了 `-i -t` 标识), 所以你可以使用键盘提供输入, 输出会显示在你的终端上.
1. 当你输入 `exit` 来终止 `/bin/bash` 命令, 容器会停止运行, 但不会被移除. 你可以再次开启它或把它移除.

#### 服务
服务使你能在多个 Docker 守护进程上拓展容器, 这些守护进程以 `swarm` 的方式协同工作, 分别担负起管理者和工作者的角色. swram 中的每个成员都是一个 Docker 守护进程, 它们都通过 Docker API 通信. 服务使你能定义需要的状态, 例如, 在任意时刻可用服务副本的数量. 服务默认会在所有工作节点间做负载均衡. 对服务使用者来说, Docker 服务的外在表现就如同一个单一的应用程序.

## 底层技术
Docker 使用 `Go` 编写, 并且利用了一些 Linux 内核特性来实现自己的功能.

### 命名空间
Docker 使用叫做 `namespace` 的技术来提供隔离的工作空间, 也即容器. 当你运行容器时, Docker 会为这个容器创建一系列命名空间.

这些命名空间提供了一个隔离层. 容器的每一方面都运行在一个单独的命名空间中, 并且只能受限地访问这个命名空间.

Docker 引擎使用了下面这些 Linux 中的命名空间:
- `pid` 命名空间: 进程隔离 (PID: Process ID)
- `net` 命名空间: 管理网络接口 (NET: Networking)
- `ipc` 命名空间: 对 IPC 资源的访问管理 (IPC: InterProcess Communication)
- `mnt` 命名空间: 管理文件系统挂载点 (MNT: Mount)
- `uts` 命名空间: 隔离内核与版本标识符 (UTS: Unix Timesharing System)

### 控制组
Linux 上的 Docker 引擎还依赖于另一项叫做控制组 (`cgroups`) 的技术. cgroup 限制了应用程序只能使用特定的资源集合. 控制组使 Docker 引擎可以分享可用的硬件资源给容器, 也可以选择添加限制. 例如, 可以限制特定容器可用的内存.

### 联合文件系统
联合文件系统, 或者 UnionFS 是指通过创建层次来操作的文件系统, 是它们非常轻快. Docker 引擎使用 UnionFS 作为容器的基础. Docker 引擎可以使用多种类型的 UnionFS, 包括 AUFS, btrfs, vfs 和 DeviceMapper.

### 容器格式
Docker 引擎将命名空间, 控制组和联合文件系统组合起来称为容器格式. 默认的容器格式为 libcontainer. 未来 Docker 或许会与 BSD Jails 或 Solaris Zones 等技术集成起来, 以支持其他的容器格式.
